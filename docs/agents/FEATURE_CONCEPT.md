ExStructを用いたAIエージェント向け編集ツール設計提案
背景と目的
ExcelドキュメントをExStructでJSON構造に変換することで、セル値・数式・図形・チャートなどを含むシート構造をプログラム的に扱えるようになります
。MCPサーバー上では、このExStructの出力JSONをAIエージェントが読み込み・解析し、必要な編集操作を自律的に決定します。エージェント側で推論（判断）を行い、MCPサーバー側では安全にその指示を実行・結果提供する役割分担となります
。本提案の目的は、AIエージェントがユーザーの確認を最小限にしつつExcelの内容編集を行えるよう、ExStruct JSONベースの編集操作ツールを設計することです。これにより、フォームへの自動入力、数式エラーの修正、新規シート作成といった処理を安全かつ再現性高く実現できる基盤を構築します。
MCP用ツール設計（OpenAPIスキーマベース）
AIエージェントが利用するMCPツールとして、新たにExStruct編集ツールを提案します。既存の抽出系ツール（exstruct_extract, exstruct_read_json_chunk, exstruct_validate_input
）に加えて、編集適用用のツールを設計します。ツール名・概要・パラメータは以下の通りです。
exstruct_patch（Excel構造編集ツール）
説明: ExStructの出力JSON（構造化Excelデータ）に対する変更パッチを適用し、Excelファイルに編集を書き戻すためのツールです。エージェントが提案した修正内容（セル値更新、数式変更、新規シート追加など）をまとめて受け取り、安全にExcelデータを更新します。
入力:
xlsx_path (string) – 編集対象とするExcelファイルのパス（読み込み元）
ops (array of object) – 適用する編集操作のリスト。各要素は以下のフィールドを持ちます：
op (string) – 操作種別（例: "set_value", "set_formula", "add_sheet"）
sheet (string) – 対象シート名（新規シート作成時は作成する名前）
cell (string) – 対象セル座標（例えば "B3"。set_value/set_formulaで使用）
value (string|number|null) – 設定するセルの値（数値・文字列など。set_value用）
formula (string) – 設定するセルの数式（=から始まるExcel数式文字列。set_formula用）
（※図形テキスト等の編集にも拡張可能：例えば op: "set_shape_text", shape_id: 図形ID, text: 新テキスト など）
out_dir (string, optional) – 編集後のExcelを書き出すディレクトリ（省略時は元ファイルと同じディレクトリ）
out_name (string, optional) – 編集後Excelファイル名（省略時は元のファイル名に自動サフィックス付与）
on_conflict (string, optional) – 出力ファイル名衝突時の扱い（"overwrite"/"skip"/"rename"から選択。未指定時はサーバー既定値を使用
）
出力:
out_path (string) – 更新後のExcelファイルパス（保存先）。
patch_diff (array of object) – 実際に適用された差分一覧（各変更の結果確認用情報。変更前後の値やシート名などを含む）
warnings (array of string, optional) – 適用時の警告メッセージ（必要に応じて）
設計の意図・特徴:
エージェントは提案する複数の編集操作をバッチ（opsリスト）で指定でき、ツール側で原子的に適用します。例えば、一度の呼び出しで複数セルの入力補完やシート追加と初期値入力を同時に行えます。xlsx_pathで指定した元ファイルは読み込み専用とし、out_pathへ結果を書き出すことで元データを保持しつつ変更版を別ファイルとして生成します（オプション指定がなければ自動リネーム保存）。このツール自体はExcelファイルを直接操作し、ExStructのJSON構造に対応する変更をExcelに反映します。Windows環境ではExcel COMまたはopenpyxlを用いてセル値・数式を書き込み、シートの追加等を行います（非Windows環境ではopenpyxlで対応）。処理完了後、どの項目がどのように変わったかをpatch_diffとして返し、エージェントはそれを用いて変更結果を検証したりユーザーに報告したりできます。
ユースケース別の処理フロー
上記ツールを用いて、想定ユースケース毎にAIエージェントがどのように編集を行うか、そのフローを示します。各ケースで、エージェントはまずExStructで既存Excelを解析し、その出力JSONを基に編集箇所と内容を決定、exstruct_patchツールにより変更を適用します。入力にはユーザーの指示や補足データ、出力にはExStruct JSON形式の変更パッチ（差分）が含まれます。
ユースケース1: 入力フォームの自動入力
想定シナリオ: ユーザーがExcel内のフォームシートに対し、「氏名」「住所」などの項目に与えられたデータを自動入力してほしいと依頼したケースです。フォームのレイアウトとして、例えばA列に項目名、B列の対応セルが空欄になっていると想定します。 処理フロー:
Excel内容の取得 – エージェントはまずexstruct_extractツールでExcelをJSON変換し
、フォームシートの構造と既存値を把握します。例えば、「氏名」や「住所」という文字列がどのセルにあるかをJSONから検索します（ExStructではセル内容はrows配列内の各行オブジェクトに格納されています
）。
入力箇所の特定 – 抽出JSONを解析し、フォーム項目名に対応する入力セル位置を特定します。具体的には、例えば「氏名」という文字列がセルA2にあり、その右隣B2が空欄であればB2が入力対象と判断されます。同様に「住所」がA3にありB3が空欄ならB3が対象になります。
パッチの生成 – ユーザーから提供されたデータ（氏名=山田太郎、住所=東京都… 等）を、対応するセルに埋め込むパッチを構築します。例えば以下のような変更リストを用意します（擬似JSON形式）：
"ops": [
{"op": "set_value", "sheet": "フォーム", "cell": "B2", "value": "山田太郎"},
{"op": "set_value", "sheet": "フォーム", "cell": "B3", "value": "東京都新宿区..."}
]
これによりフォームシート「フォーム」のB2セルに「山田太郎」、B3セルに住所テキストを入力する指示となります。
パッチの適用 – エージェントは構築した変更パッチをexstruct_patchツールに渡し実行します。ツール内部では、指定Excelファイルの該当セルを書き換え、新しいExcelを保存します。出力には、例えばB2が空白から「山田太郎」に変わったこと、B3が空白から住所文字列に変わったことを示す差分情報が含まれます。
結果の検証・利用 – エージェントは返されたpatch_diffを確認し、想定通り入力が行われたか検証します。問題なければユーザーに対し「フォームに指定のデータを入力しました」と回答し、必要に応じて更新後のExcelファイル（out_pathで示されるファイル）を提供します。変更内容は差分として記録されており、後から監査可能です。
※内部的には、ExStruct JSONのrowsデータ（セル値マップ）でB2, B3に相当する箇所が更新されるイメージです
。ユーザー確認なしでも誤入力を防ぐため、エージェントは項目名と入力内容の対応を二重チェックし、フォーマット不整合（例えば数値フィールドに文字列を入れる等）が無いか検証します。
ユースケース2: 数式エラーの修正
想定シナリオ: Excelシート内のあるセルが#DIV/0!や#REF!等のエラーを示しており、ユーザーが「この数式エラーを修正してほしい」と依頼したケースです。例えば、シート「計算」で総計を求める数式が誤参照によりエラーになっている状況を考えます。 処理フロー:
エラーの検出 – エージェントはまずexstruct_extractでブック全体をJSON化し、formulas_mapなどを参照してエラーのある数式を探します。ExStructのformulas_mapには「数式文字列 → セル座標」の対応が含まれており
、これを使って該当セルの数式テキストを取得できます（例えばエラーが発生しているセルC10の数式が=SUM(A1:A9)だった等を把握）。また、rows内の該当セル値がエラー文字列（"#DIV/0!" 等）になっていることも確認します。
原因分析 – 抽出した数式文字列および周辺データからエラー原因を推測します。例えば、#REF!であれば参照範囲のシート名・セル範囲の誤り、#DIV/0!であれば除数が0になり得ることが原因かもしれません。エージェントは他のセル値もrowsデータから参照し、問題の数式が何をしようとしているか理解します。必要に応じてユーザーから追加情報（正しい参照先など）を引き出すことも考えられます。
修正内容の決定 – 原因に応じて新しい数式を提案します。例えば、#REF!なら参照すべき正しいシート名に修正、#DIV/0!なら除数が0の場合に0を返すようなIF関数の追加、などです。ここではシート「計算」のC10が=SUM(Shee1!A:A)となっておりシート名のタイポで#REF!になっている例を考えます（正しくはSheet1）。修正数式は =SUM(Sheet1!A:A) に直す方針と決定します。
パッチの生成 – 決定した修正を反映するパッチを作成します。上記例ではシート「計算」のセルC10の数式を書き換える操作となります。パッチ例:
"ops": [
{"op": "set_formula", "sheet": "計算", "cell": "C10", "formula": "=SUM(Sheet1!A:A)"}
]
これによりC10セルの数式文字列を新しいものに置き換えます（ExStructのformulas_map上も旧数式キーから新数式キーへの更新が行われるイメージです）。必要に応じ、数式結果の再計算はExcel側で開く際に行われるため、ここでは値の更新は行いません（値はユーザーがExcelを開いて再計算した際に得られる）。
パッチの適用 – エージェントはexstruct_patchを使い上記パッチを適用します。Excelファイル上でセルC10の数式が書き換わり、新しいExcelファイルが保存されます。patch_diffには「C10の数式: =SUM(Shee1!A:A) から =SUM(Sheet1!A:A) に変更した」旨の記録が残ります。
結果の検証 – エージェントは返された差分を確認し、確かに意図した変更が行われたことを確認します。可能であればexstruct_extractで再度JSONを取得し、エラー表示が消えたか（ExStruct上はセルC10の値が今度はエラー文字列以外になっているか）をチェックしても良いでしょう。修正が正しければ、ユーザーに対し「数式の参照ミスを修正しました。これでエラーは解消するはずです」と伝え、更新後のExcelを提供します。
※ExStructではformulas_mapにより複数セルで同一数式が使われている場合まとめられていますが
、個別セルの修正では該当エントリのみを差し替えます（内部実装では旧数式キーの該当セル座標を削除し、新数式キーにセル座標を追加する処理となります）。エージェントはこのような低レベル実装詳細を意識せず高水準な操作指定（「セルC10の数式を書き換え」）を行い、ツール側で正確な差分反映を行います。
ユースケース3: ゼロからのシート作成
想定シナリオ: 空の新規シートを追加し、そこに必要な表や値を自動生成してほしいケースです。ユーザーが「売上データを集計した新しいシートを作って」と依頼するといった状況を考えます。 処理フロー:
内容と構成のプランニング – エージェントはユーザーの要求を解析し、新シートに何を作るかを決めます。例えば「売上集計」シートを作成し、既存の「売上明細」シートから月別売上合計を計算してまとめる、など具体的なプランを立てます。この段階で必要ならexstruct_extractやread_json_chunkで元データ（売上明細シートの内容）を取得し、計算に使います。
シート名の決定と競合確認 – 新規シート名を決めます（例: 「売上集計」）。既に同名のシートが存在しないか、ExStruct JSONのsheetsマップを確認して競合を避けます
（存在する場合は自動で別名を付けるかユーザーに確認します）。
初期データ/書式の生成 – シートに配置するデータやヘッダ行、計算式などを決定します。例えば1行目にヘッダ「月」「売上合計」を入れ、2行目以降に1月～12月の売上合計値を計算して入れる、というようにレイアウトと内容を準備します。計算式もここで用意し（例えばB2に=SUM('売上明細'!B2:B31)など）、論理チェックを行います。
パッチの生成 – 新シート追加とセル内容設定を含む変更パッチを構築します。例えば以下のようになります：
"ops": [
{"op": "add_sheet", "sheet": "売上集計"},
{"op": "set_value", "sheet": "売上集計", "cell": "A1", "value": "月"},
{"op": "set_value", "sheet": "売上集計", "cell": "B1", "value": "売上合計"},
{"op": "set_value", "sheet": "売上集計", "cell": "A2", "value": "1月"},
{"op": "set_formula", "sheet": "売上集計", "cell": "B2", "formula": "=SUM('売上明細'!B2:B31)"}
// 以下 A3に"2月", B3にSUM(...), ... と続く
]
最初のadd_sheetによりブックに名前「売上集計」のシートを追加し、続くset_valueおよびset_formulaでそのシート上のセルを順次設定していきます（ヘッダ行と1月の集計式のみ例示）。パッチ内の操作順序は考慮され、add_sheetが他の操作より先に適用されることで、新シート上に値を書き込む処理が可能になります。
パッチの適用 – exstruct_patchを呼び出し変更を適用します。これによって元Excelに「売上集計」シートが追加され、指定のセルに値・数式が書き込まれた新しいExcelファイルが生成されます。patch_diffには新規シート作成とセル値入力が一覧化されます。例えば「新規シート '売上集計' を追加」「'売上集計'!A1 に '月' を設定」「'売上集計'!B2 に数式 '=SUM('売上明細'!B2:B31)' を設定」などと記録されます。
結果確認 – エージェントは差分ログや再抽出結果を検証し、シート追加とデータ配置が指示通りになっていることを確認します。必要ならば新シートの内容をexstruct_read_json_chunkで読み出し、意図した値・式になっているかチェックします。問題なければユーザーに「新しい集計シート '売上集計' を追加しました」と伝え、ファイルパスを共有します。
この処理により、ゼロからシートを生成する操作も自動化できます。opsリストにまとめて記述できるため、一括適用による一貫性確保（シート追加と内容設定の一体化）や、過程の中間状態がユーザー確認なしでも整合するメリットがあります。
編集対象フィールドと変更内容の対応
各ユースケースで操作するExStruct内部フィールドを整理します。提案ツールはExStruct出力JSONを直接修正・拡張する形でExcel編集を行います。
セル値 (Cells) – フォーム自動入力や値修正では、JSON構造内の各シートのrows配列にある該当セル値を更新します
。例えば上記ケース1ではシート「フォーム」の該当行オブジェクト内のcマップでキー「B」に対応する値を書き換える操作に相当します。新規値はJSON上もExcel上も文字列または数値として保存されます。
数式 (Formulas) – 数式の変更では、Excel上はセルの数式文字列を書き換えます。ExStruct JSON上はformulas_mapに格納されたエントリを更新することに対応します
（内部的には旧数式のエントリから該当セルを削除し、新数式文字列のキーにセルを紐付ける操作となります）。またExcelファイル上は新しい数式が設定されます。注: ExStructの抽出JSONはセルの計算結果値も保持しますが、再計算が必要な場合この値は古いままの場合があります。エージェントは必要ならユーザーにExcel上で再計算（F9押下等）するよう注意喚起します。
シート (Sheets) – 新規シートの追加では、JSONのworkbook["sheets"]オブジェクトに新しいキー（シート名）を追加し、その値として空のSheetData構造を作る操作に相当します
。内部ではExcelファイルに対してシートを追加し、ExStructエンジンで扱える構造（空のrows配列等を持つ）を初期化します。その後のセル入力はこの新規シート内のデータ構造に対する更新です。既存シート名の変更や削除も将来的には対応可能ですが、本提案範囲では扱いません。
図形・その他オブジェクト (Shapes etc) – ユースケースには直接登場しませんでしたが、ExStruct JSONには図形やスマートアート、チャート等の情報も含まれます
。テキストボックス型の図形に入力された文字列を編集する、といった操作も考えられます。この場合、該当シートのshapes配列から対象オブジェクト（例えばidで特定）を見つけ、そのtextフィールドを更新するパッチを用意します。提案ツールではop: "set_shape_text"等の拡張的な操作もサポート可能であり、他の操作と同様に差分として記録・適用します。チャートやSmartArtに対する大規模な構造変更は複雑ですが、例えばチャートタイトルのテキスト差し替え程度であれば同様のアプローチで実現できます。
安全性とトレーサビリティ
AIエージェントによる自律的なExcel編集においては、誤操作の防止と変更履歴の追跡が極めて重要です。本設計では以下の工夫により安全性とトレーサビリティを確保します。
ルートディレクトリ固定とパス検証: MCPサーバー起動時に--rootオプションで許可ディレクトリを定め、エージェントはその配下のファイルしか操作できません
。ツール実行時も内部でパス正規化とdeny_globチェックを行い、不正なパスや想定外のファイルアクセスをブロックします
。これにより、エージェントが誤って機密ファイルを編集したり、悪意ある指示で外部に影響を及ぼすリスクを低減します。
オープンAPIスキーマによる入力制約: 提案ツールのパラメータはOpenAPIスキーマに基づき厳格に定義されています。例えばops配列内の各フィールド型・必須/省略可能要素は事前に決められており、エージェントのリクエストは自動検証されます。スキーマ不一致の入力（存在しないシート名や無効なセル番地形式など）は即座にエラーとなり、実ファイルに手を加える前に検出されます。これにより、エージェントのバグやLLMの勘違いによる不正確な操作を未然に防ぎます。
差分適用の原子性: 一連の編集opsはすべて成功した場合にのみコミットされます。途中で無効な参照（例: 存在しないセル）や競合が判明した場合、ツールはエラーを返しExcelは変更されません。これにより、部分的変更でデータ不整合が生じることを防ぎます。
出力ファイルの競合回避: 既定ではexstruct_patchは元ファイルを上書きせず新規ファイルとして保存します。--on-conflict設定により同名ファイルがある場合はリネームやスキップも可能です
。安全策としてデフォルトはrename（連番等で新ファイル名生成）とし、うっかり既存ファイルを消してしまう事故を防ぎます。ユーザーが明示的に許可した場合のみ上書きモードを使う運用を推奨します。
変更履歴のログ: exstruct_patchは適用内容をpatch_diffとして詳細に返します。各エントリには変更対象（シート名・セル座標など）、変更前の値（可能な場合）と変更後の値が含まれます。これをサーバー側でログ蓄積することで、後から「どのセルをどう変えたか」を追跡できます。ユーザーは履歴をレビューしたり、不備が見つかった場合に該当変更のみをUndo（取り消し）することも可能です。Undoは、記録された変更前値を用いて逆パッチを適用すれば実現できます。例えば、「B2を空白から山田太郎に変更」という記録があれば、その逆操作「B2を山田太郎から空白に」がUndoに相当します。エージェントは自律動作中でも必要に応じて過去ログを参照し、二重入力や再変更による矛盾を避けます。
ユーザー確認ポイントの最小化と確保: 基本的にエージェントは上記仕組みにより自律的に編集を完了できますが、リスクの高い操作（大量のセル削除や大幅なレイアウト変更など）は事前にユーザー確認を要求することも検討できます。本提案ではフォーム入力や局所的な計算修正といったスコープ限定の変更を対象としており、通常は自動承認で進めます。一方、新規シート追加のようにユーザーの意図を汲み取る必要があるケースでは、エージェントが推測に基づく内容（例: 集計方法）を実装する前に「この方針で進めますがよろしいですか？」と質問することも可能です。ただしこれはプロンプト設計レベルで制御し、MCPツール自体はユーザー確認のフローを持ちません。必要な確認はエージェントが対話を通じて行い、確定したら一括適用する方針です。
例外とエラー処理: ツール実行時に発生し得るエラー（例えばExcelファイル破損、シート名の競合、権限不足など）はツールからエージェントへ明示的に返されます（warningsやエラーメッセージとして）。エージェントはこれを解釈し、ユーザーへの報告やリトライ（別名で再作成する等）を行います。こうしたフェイルセーフ設計により、意図しないSilent failure（失敗に気付かない状態）を防ぎます。
以上の対策により、AIエージェントによるExcel編集操作は、閉じた安全な環境内でトレース可能な形で実行されます。ログとパッチによる再現性確保により、後からでも変更を再適用したり原因分析したりが容易です。ユーザーは安心してエージェントにExcel編集を任せることができ、必要に応じて結果だけを確認するという使い方が可能になります。
プロンプト例（LLMへの指示）
最後に、想定ユースケースに対してユーザーがAIエージェントに与える指示（プロンプト）の代表例を示します。エージェントはこれらの指示を受け取り、内部でExStruct MCPツールを駆使して前述の編集フローを実行します。
フォーム自動入力の例: 「添付のExcelフォームに、社員情報を自動入力してください。氏名は山田太郎、住所は東京都新宿区西新宿2-8-1、電話番号は03-1234-5678です。」
数式エラー修正の例: 「Excelの『計算』シートでセルC10に#REF!エラーが出ています。正しい参照範囲は同ブックの『Sheet1』シートです。このエラーを修正してください。」
新規シート作成の例: 「現在のExcelブックに、新しく『売上集計』シートを追加してください。既存の『売上明細』シートから月ごとの売上合計を計算し、月別に一覧でまとめて配置してください。」
これらのプロンプトに対し、エージェントは適切にExStructの抽出結果を分析し、設計したツールを用いて安全に編集を行います。例えばフォーム入力の依頼では、自動で対応セルを見つけ出し値を埋め、ユーザーに完成したフォームを提示します。数式修正では、誤った参照を正しいものに直し、新規シート作成では要求通りの集計シートを構築します。全ての操作はExStruct JSON中間表現を介して行われるため、AIエージェントはExcelのGUI操作をすることなく構造的かつ再現性のある編集を実現できます。ユーザーは最終的に編集後のExcelファイルと、必要なら変更概要の説明を受け取り、従来手作業では困難だった高度な処理も自動化された形で享受できます。
